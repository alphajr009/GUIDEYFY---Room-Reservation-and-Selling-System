System.register([], (function (exports) {
  'use strict';
  return {
    execute: (function () {

      exports('devtools', devtools);

      var __defProp$1 = Object.defineProperty;
      var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
      var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
      var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
      var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __spreadValues$1 = (a, b) => {
        for (var prop in b || (b = {}))
          if (__hasOwnProp$1.call(b, prop))
            __defNormalProp$1(a, prop, b[prop]);
        if (__getOwnPropSymbols$1)
          for (var prop of __getOwnPropSymbols$1(b)) {
            if (__propIsEnum$1.call(b, prop))
              __defNormalProp$1(a, prop, b[prop]);
          }
        return a;
      };
      const redux = exports('redux', (reducer, initial) => (set, get, api) => {
        api.dispatch = (action) => {
          set((state) => reducer(state, action), false, action);
          return action;
        };
        api.dispatchFromDevtools = true;
        return __spreadValues$1({ dispatch: (...a) => api.dispatch(...a) }, initial);
      });

      function devtools(fn, options) {
        return (set, get, api) => {
          var _a;
          let didWarnAboutNameDeprecation = false;
          if (typeof options === "string" && !didWarnAboutNameDeprecation) {
            console.warn("[zustand devtools middleware]: passing `name` as directly will be not allowed in next majorpass the `name` in an object `{ name: ... }` instead");
            didWarnAboutNameDeprecation = true;
          }
          const devtoolsOptions = options === void 0 ? { name: void 0, anonymousActionType: void 0 } : typeof options === "string" ? { name: options } : options;
          if (typeof ((_a = devtoolsOptions == null ? void 0 : devtoolsOptions.serialize) == null ? void 0 : _a.options) !== "undefined") {
            console.warn("[zustand devtools middleware]: `serialize.options` is deprecated, just use `serialize`");
          }
          let extensionConnector;
          try {
            extensionConnector = window.__REDUX_DEVTOOLS_EXTENSION__ || window.top.__REDUX_DEVTOOLS_EXTENSION__;
          } catch {
          }
          if (!extensionConnector) {
            if (typeof window !== "undefined") {
              console.warn("[zustand devtools middleware] Please install/enable Redux devtools extension");
            }
            return fn(set, get, api);
          }
          let extension = Object.create(extensionConnector.connect(devtoolsOptions));
          let didWarnAboutDevtools = false;
          Object.defineProperty(api, "devtools", {
            get: () => {
              if (!didWarnAboutDevtools) {
                console.warn("[zustand devtools middleware] `devtools` property on the store is deprecated it will be removed in the next major.\nYou shouldn't interact with the extension directly. But in case you still want to you can patch `window.__REDUX_DEVTOOLS_EXTENSION__` directly");
                didWarnAboutDevtools = true;
              }
              return extension;
            },
            set: (value) => {
              if (!didWarnAboutDevtools) {
                console.warn("[zustand devtools middleware] `api.devtools` is deprecated, it will be removed in the next major.\nYou shouldn't interact with the extension directly. But in case you still want to you can patch `window.__REDUX_DEVTOOLS_EXTENSION__` directly");
                didWarnAboutDevtools = true;
              }
              extension = value;
            }
          });
          let didWarnAboutPrefix = false;
          Object.defineProperty(extension, "prefix", {
            get: () => {
              if (!didWarnAboutPrefix) {
                console.warn("[zustand devtools middleware] along with `api.devtools`, `api.devtools.prefix` is deprecated.\nWe no longer prefix the actions/names" + devtoolsOptions.name === void 0 ? ", pass the `name` option to create a separate instance of devtools for each store." : ", because the `name` option already creates a separate instance of devtools for each store.");
                didWarnAboutPrefix = true;
              }
              return "";
            },
            set: () => {
              if (!didWarnAboutPrefix) {
                console.warn("[zustand devtools middleware] along with `api.devtools`, `api.devtools.prefix` is deprecated.\nWe no longer prefix the actions/names" + devtoolsOptions.name === void 0 ? ", pass the `name` option to create a separate instance of devtools for each store." : ", because the `name` option already creates a separate instance of devtools for each store.");
                didWarnAboutPrefix = true;
              }
            }
          });
          let isRecording = true;
          api.setState = (state, replace, nameOrAction) => {
            set(state, replace);
            if (!isRecording)
              return;
            extension.send(nameOrAction === void 0 ? { type: devtoolsOptions.anonymousActionType || "anonymous" } : typeof nameOrAction === "string" ? { type: nameOrAction } : nameOrAction, get());
          };
          const setStateFromDevtools = (...a) => {
            const originalIsRecording = isRecording;
            isRecording = false;
            set(...a);
            isRecording = originalIsRecording;
          };
          const initialState = fn(api.setState, get, api);
          extension.init(initialState);
          if (api.dispatchFromDevtools && typeof api.dispatch === "function") {
            let didWarnAboutReservedActionType = false;
            const originalDispatch = api.dispatch;
            api.dispatch = (...a) => {
              if (a[0].type === "__setState" && !didWarnAboutReservedActionType) {
                console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.');
                didWarnAboutReservedActionType = true;
              }
              originalDispatch(...a);
            };
          }
          extension.subscribe((message) => {
            var _a2;
            switch (message.type) {
              case "ACTION":
                if (typeof message.payload !== "string") {
                  console.error("[zustand devtools middleware] Unsupported action format");
                  return;
                }
                return parseJsonThen(message.payload, (action) => {
          